<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>WGD inference using reversible-jump MCMC and gene count data · Beluga.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Beluga.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../mle/">Maximum likelihood estimation for the DLWGD model using <code>Beluga.jl</code></a></li><li><a class="tocitem" href="../prior/">Sample from the prior using rjMCMC</a></li><li class="is-active"><a class="tocitem" href>WGD inference using reversible-jump MCMC and gene count data</a></li></ul></li><li><a class="tocitem" href="../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>WGD inference using reversible-jump MCMC and gene count data</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>WGD inference using reversible-jump MCMC and gene count data</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/arzwa/Beluga.jl/blob/master/docs/src/rjmcmc.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="WGD-inference-using-reversible-jump-MCMC-and-gene-count-data-1"><a class="docs-heading-anchor" href="#WGD-inference-using-reversible-jump-MCMC-and-gene-count-data-1">WGD inference using reversible-jump MCMC and gene count data</a><a class="docs-heading-anchor-permalink" href="#WGD-inference-using-reversible-jump-MCMC-and-gene-count-data-1" title="Permalink"></a></h1><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Please note that all analyses below are on a small test data set and use short MCMC runs. This is of course not recommended in practice, but simply to make generating this page feasible in reasonable time.</p></div></div><p>Load Beluga and required packages:</p><pre><code class="language-julia">using Beluga, CSV, Distributions, Random
Random.seed!(23031964)</code></pre><pre><code class="language-none">Random.MersenneTwister(UInt32[0x015f709c], Random.DSFMT.DSFMT_state(Int32[-767906194, 1073601484, 1994176309, 1073658613, 111759256, 1073640127, 319734154, 1073527007, 1773971897, 1073085338  …  -1224132512, 1072863464, 385170543, 1073076045, -1232795947, 1995616467, 149752818, -2058204503, 382, 0]), [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], UInt128[0x00000000000000000000000000000000, 0x00000000000000000000000000000000, 0x00000000000000000000000000000000, 0x00000000000000000000000000000000, 0x00000000000000000000000000000000, 0x00000000000000000000000000000000, 0x00000000000000000000000000000000, 0x00000000000000000000000000000000, 0x00000000000000000000000000000000, 0x00000000000000000000000000000000  …  0x00000000000000000000000000000000, 0x00000000000000000000000000000000, 0x00000000000000000000000000000000, 0x00000000000000000000000000000000, 0x00000000000000000000000000000000, 0x00000000000000000000000000000000, 0x00000000000000000000000000000000, 0x00000000000000000000000000000000, 0x00000000000000000000000000000000, 0x00000000000000000000000000000000], 1002, 0)</code></pre><p>Or, if you are running a julia session with multiple processes (when you started julia with <code>-p</code> option, or manually added workers using <code>addprocs</code>, see <a href="https://docs.julialang.org/en/v1/manual/parallel-computing/index.html#Parallel-Computing-1">julia docs</a>), run:</p><pre><code class="language-julia">using CSV, Distributions
@everywhere using Beluga  # if julia is running in a parallel environment</code></pre><p>Then get some data (for instance from the <code>example</code> directory of the git repo)</p><pre><code class="language-">nw = readline(joinpath(@__DIR__, &quot;../../example/9dicots/9dicots.nw&quot;))
df = CSV.read(joinpath(@__DIR__, &quot;../../example/9dicots/9dicots-f01-25.csv&quot;))
model, data = DLWGD(nw, df, 1.0, 1.2, 0.9)</code></pre><p><code>model</code> now refers to the duplication-loss and WGD model (with no WGDs for now), <code>data</code> refers to the phylogenetic profile matrix. The model was initialized with all duplication and loss rates set to 1 and 1.2 respectively. You can check this easily:</p><pre><code class="language-">getrates(model)</code></pre><p>or to get the full parameter vector:</p><pre><code class="language-">asvector(model)</code></pre><p>Now you can easily compute log-likelihoods (and gradients thereof)</p><pre><code class="language-">logpdf!(model, data)</code></pre><p>so we can do likelihood-based inference (either maximum-likelihood or Bayesian). For the kind of problems tackled here, the only viable option however is Bayesian inference.</p><p>We proceed by specifying the hierarchical prior on the gene family evolutionary process. There is no DSL available (à la Turing.jl, Mamba.jl, Soss.jl or Stan) but we use a fairly flexible prior struct. Here is an exaple for the (recommended) bivariate independent rates (IR) prior:</p><pre><code class="language-">prior = IRRevJumpPrior(
    Ψ=[1 0. ; 0. 1],
    X₀=MvNormal([0., 0.], [1 0. ; 0. 1]),
    πK=DiscreteUniform(0,20),
    πq=Beta(1,1),
    πη=Beta(3,1),
    Tl=treelength(model))</code></pre><p><code>Ψ</code> is the prior covariance matrix for the Inverse-Wishart distribution. <code>X₀</code> is the multivariate Normal prior on the mean duplication and loss rates. <code>πK</code> is the prior on the number of WGDs (i.e. the model indicator). <code>πq</code> is the Beta prior on the retention rates (iid). <code>πη</code> is the hyperprior on the parameter of the geometric distribution on the number of ancestral lineages at the root. <code>Tl</code> is the tree length (and is used for the prior on the WGD ages).</p><p>To sample across model-space (i.e. where we infer the number and locations of WGDs), we need the reversible jump algorithm. There are several reversible-jump kernels implemented. Each reversible jump kernel introduces a WGD with probability 1/2 (forward jump) or removes a WGD with probability 1/2 (reverse jump). The simplest is the aptly named <code>SimpleKernel</code>, which introduces new WGDs with a random retention rate drawn from a Beta distribution.</p><pre><code class="language-julia">kernel = SimpleKernel(qkernel=Beta(1,3))</code></pre><pre><code class="language-none">SimpleKernel
  qkernel: Distributions.Beta{Float64}
  accepted: Int64 0
</code></pre><p>The differences between the kernels is the parameter updates that are applied during these jumps. Kernel 1 (<code>SimpleKernel</code>) only introduces/removes a WGD and does not modify the duplication and loss rates on the associated branch, kernel 2 (<code>DropKernel</code>) introduces/removes a WGD and concomitantly decreases/increases the duplication rate by a random amount and kernel 3 (<code>BranchKernel</code>) introduces/removes a WGD, decreases/increases the duplication rate and increases/decreases the loss rate (randomly). As, in contrast with ordinary Metropolis-Hastings MCMC proposals, tuning of the reversible-jump kernel is not possible automatically (or at least, I&#39;m unsure how it should be done), it can be worthwhile to do some initial short pilot runs on a small data set to figure out a parameterization that results in a reasonably high jump probability (<code>pjmp</code> in the output). Usually, using the same distribution for the <code>qkernel</code> as the prior on <code>q</code> is a good idea.</p><p>We can now construct a chain object bundling everything</p><pre><code class="language-">chain = RevJumpChain(data=data, model=model, prior=prior, kernel=kernel)
init!(chain)</code></pre><p>and sample from it:</p><pre><code class="language-">@time rjmcmc!(chain, 1000, show=50)</code></pre><p>This will log a part of the trace to stdout every <code>show</code> iterations, so that we&#39;re able to monitor a bit whether everything looks sensible. Of course in reality you would sample way longer than <code>n=1000</code> iterations, but since this page has to be generated in decent time using a single CPU I&#39;ll keep it to 1000 here.</p><p>Now the computer has done Bayesian inference, and we have to do our part. We can analyze the trace (in <code>chain.trace</code>), write it to a file, compute statistics, etc. Here are some trace plots:</p><pre><code class="language-">using Plots, DataFrames, LaTeXStrings
burnin=100
p1 = plot(chain.trace[burnin:end,:λ1], label=L&quot;\lambda_1&quot;)
plot!(chain.trace[burnin:end,:μ1], label=L&quot;\mu_1&quot;)
p2 = plot(chain.trace[burnin:end,:λ8], label=L&quot;\lambda_8&quot;)
plot!(chain.trace[burnin:end,:μ8], label=L&quot;\mu_8&quot;)
p3 = plot(chain.trace[!,:k], label=L&quot;k&quot;)
p4 = plot(chain.trace[!,:η1], label=L&quot;\eta&quot;)
plot(p1,p2,p3,p4, grid=false, layout=(2,2))</code></pre><p>Clearly, we should sample way longer to get decent estimates for the duplication rates (<code>λ</code>), loss rates (<code>μ</code>) and number of WGDs (<code>k</code>). Note how <code>η</code> is quite well-sampled already.</p><p>We can also check the effective sample size (ESS) of the model indicator variable, for that we will use the method of Heck et al. (2019) implemented in the module <a href="https://github.com/arzwa/DiscreteMarkovFit.jl"><code>DiscreteMarkovFit.jl</code></a>:</p><pre><code class="language-julia">using DiscreteMarkovFit</code></pre><p>We&#39;ll discard a burnin of 100 iterations</p><pre><code class="language-">d = ObservedBirthDeathChain(Array(chain.trace[100:end,:k]))
out = DiscreteMarkovFit.sample(d, 10000)</code></pre><p>This shows the effective sample size for the number of WGDs and the associated posterior probabilities. The maximum a posteriori (MAP) number of WGDs here is three. When doing a serious analysis, one should aim for higher ESS values of course. Note that if one is interested in WGDs for a specific branch, it is also relevant to look at that variable, for instance for the poplar branch</p><pre><code class="language-">d = ObservedBirthDeathChain(Array(chain.trace[100:end,:k10]))
out = DiscreteMarkovFit.sample(d, 10000)</code></pre><p>We can also compute Bayes factors to get an idea of the number of WGDs for each branch in the species tree.</p><pre><code class="language-">bfs = bayesfactors(chain, burnin=100);
nothing #hide</code></pre><p>This suggests strong support for WGD in quinoa (<code>cqu</code>), for which we know the genome shows a strong signature of an ancestral WGD.  Note that we already detect these WGDs using a mere 25 gene families as data!</p><p>A plot of the posterior probabilities for the number of WGDs on each branch is a nice way to summarize the rjMCMC output:</p><pre><code class="language-">plots = [bar(g[!,:k], g[!,:p1], color=:white,
            title=join(string.(g[1,:clade]), &quot;, &quot;))
            for g in groupby(bfs, :branch)]
xlabel!.(plots[end-3:end], L&quot;k&quot;)
ylabel!.(plots[1:4:end], L&quot;P(k|X)&quot;)
plot(plots..., grid=false, legend=false,
    ylim=(0,1), xlim=(-0.5,3.5),
    yticks=[0, 0.5, 1], xticks=0:3,
    title_loc=:left, titlefont=8)</code></pre><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../prior/">« Sample from the prior using rjMCMC</a><a class="docs-footer-nextpage" href="../api/">API »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 24 November 2020 07:22">Tuesday 24 November 2020</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
