var documenterSearchIndex = {"docs":
[{"location":"api/#API-1","page":"API","title":"API","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Modules = [Beluga]","category":"page"},{"location":"api/#Beluga.BMRevJumpPrior","page":"API","title":"Beluga.BMRevJumpPrior","text":"BMRevJumpPrior\n\nBivariate autocorrelated rates (Brownian motion) prior inspired by coevol (Lartillot & Poujol 2010) with an Inverse Wishart prior on the unknown covariance 2×2 matrix. Crucially, this is defined for the Node based model, i.e. states at model nodes are assumed to be states at nodes of the phylogeny.\n\n\n\n\n\n","category":"type"},{"location":"api/#Beluga.BranchKernel","page":"API","title":"Beluga.BranchKernel","text":"BranchKernel\n\nReversible jump kernel that introduces a WGD, decreases λ and increases μ on the associated branch.\n\n\n\n\n\n","category":"type"},{"location":"api/#Beluga.CRRevJumpPrior","page":"API","title":"Beluga.CRRevJumpPrior","text":"CRRevJumpPrior\n\nConstant-rates model.\n\n\n\n\n\n","category":"type"},{"location":"api/#Beluga.DLWGD","page":"API","title":"Beluga.DLWGD","text":"DLWGD{T<:Real,V<:ModelNode{T}}\n\nDuplication, loss and WGD model. This holds a dictionary for easy access of the nodes in the probabilistic graphical model and the leaf names.\n\n\n\n\n\n","category":"type"},{"location":"api/#Beluga.DLWGD-Tuple{DataFrames.DataFrameRow}","page":"API","title":"Beluga.DLWGD","text":"(m::DLWGD)(row::DataFrameRow)\n\nInstantiate a model based on a row from a trace data frame. This returns a modified copy of the input model.\n\n\n\n\n\n","category":"method"},{"location":"api/#Beluga.DropKernel","page":"API","title":"Beluga.DropKernel","text":"DropKernel\n\nReversible jump kernel that introduces a WGD and decreases λ on the associated branch.\n\n\n\n\n\n","category":"type"},{"location":"api/#Beluga.IRRevJumpPrior","page":"API","title":"Beluga.IRRevJumpPrior","text":"IRRevJumpPrior\n\nBivariate uncorrelated rates prior with an Inverse Wishart prior on the unknown covariance 2×2 matrix. Crucially, this is defined for the Branch based model, i.e. states at model nodes are assumed to be states at branches of the phylogeny.\n\n\n\n\n\n","category":"type"},{"location":"api/#Beluga.PArray","page":"API","title":"Beluga.PArray","text":"PArray{T<:Real}\n\nDitributed array of phylogenetic profiles.\n\n\n\n\n\n","category":"type"},{"location":"api/#Beluga.PostPredSim","page":"API","title":"Beluga.PostPredSim","text":"PostPredSim(chain, data::DataFrame, n::Int64)\n\nPerform posterior predictive simulations.\n\n\n\n\n\n","category":"type"},{"location":"api/#Beluga.Profile","page":"API","title":"Beluga.Profile","text":"Profile{T<:Real}\n\nStruct for a phylogenetic profile of a single family. Geared towards MCMC applications (temporary storage fields) and parallel applications (using DArrays). See also PArray.\n\n\n\n\n\n","category":"type"},{"location":"api/#Beluga.RevJumpChain","page":"API","title":"Beluga.RevJumpChain","text":"RevJumpChain\n\nReversible jump chain struct for DLWGD model inference.\n\n!!! note After construction, an explicit call to init! is required.\n\n\n\n\n\n","category":"type"},{"location":"api/#Beluga.SimpleKernel","page":"API","title":"Beluga.SimpleKernel","text":"SimpleKernel\n\nReversible jump kernel that only introduces a WGD while not chnging λ or μ.\n\n\n\n\n\n","category":"type"},{"location":"api/#Beluga.addwgd!-Union{Tuple{T}, Tuple{DLWGD{T,V} where V<:Union{NewickTree.TreeNode{Beluga.Branch{T}}, NewickTree.TreeNode{Beluga.Node{T}}},Union{NewickTree.TreeNode{Beluga.Branch{T}}, NewickTree.TreeNode{Beluga.Node{T}}},T,T}} where T<:Real","page":"API","title":"Beluga.addwgd!","text":"addwgd!(d::DLWGD, n::ModelNode, t, q)\n\nInsert a WGD node with retention rate q at distance t above node n.\n\n\n\n\n\n","category":"method"},{"location":"api/#Beluga.addwgds!-Tuple{DLWGD,DistributedArrays.DArray{Profile{T},1,Array{Profile{T},1}} where T<:Real,Array}","page":"API","title":"Beluga.addwgds!","text":"addwgds!(m::DLWGD, p::PArray, config::Array)\n\nAdd WGDs from array of named tuples e.g. [(lca=\"ath,cpa\", t=rand(), q=rand())] and update the profile array.\n\n\n\n\n\n","category":"method"},{"location":"api/#Beluga.addwgds!-Tuple{DLWGD,DistributedArrays.DArray{Profile{T},1,Array{Profile{T},1}} where T<:Real,String}","page":"API","title":"Beluga.addwgds!","text":"addwgds!(m::DLWGD, p::PArray, config::String)\naddwgds!(m::DLWGD, p::PArray, config::Dict{Int64,Tuple})\n\nAdd WGDs from a (stringified) dictionary (as in the wgds column of the trace data frame in rjMCMC applications) and update the profile array.\n\n\n\n\n\n","category":"method"},{"location":"api/#Beluga.asvector-Tuple{DLWGD}","page":"API","title":"Beluga.asvector","text":"asvector(d::DLWGD)\n\nGet a parameter vector for the DLWGD model, structured as [λ1, …, λn, μ1, …, μn, q1, …, qk, η].\n\n\n\n\n\n","category":"method"},{"location":"api/#Beluga.bayesfactors-Tuple{Any}","page":"API","title":"Beluga.bayesfactors","text":"bayesfactors(trace::DataFrame, model::DLWGD, p::Float64)\n\nCompute Bayes Factors for all branch WGD configurations. Returns a data frame that is more or less self-explanatory.\n\n\n\n\n\n","category":"method"},{"location":"api/#Beluga.getrates-Union{Tuple{DLWGD{T,V} where V<:Union{NewickTree.TreeNode{Beluga.Branch{T}}, NewickTree.TreeNode{Beluga.Node{T}}}}, Tuple{T}} where T","page":"API","title":"Beluga.getrates","text":"getrates(model::DLWGD{T})\n\nGet the duplication and loss rate matrix (2 × n).\n\n\n\n\n\n","category":"method"},{"location":"api/#Beluga.getwgdtrace-Tuple{RevJumpChain}","page":"API","title":"Beluga.getwgdtrace","text":"getwgdtrace(chain)\n\nSummarize all WGD models from an rjMCMC trace. This provdes the data to evaluate retention rates for WGD models etc. Returns a dict of dicts with data frames (which is a horrible data structure, I know) structured as (branch1 => (1 WGD => trace, 2 WGDs => trace, ...), branch2 => (), ...).\n\n\n\n\n\n","category":"method"},{"location":"api/#Beluga.gradient-Union{Tuple{T}, Tuple{DLWGD,DistributedArrays.DArray{Profile{T},1,Array{Profile{T},1}}}} where T","page":"API","title":"Beluga.gradient","text":"gradient!(d::DLWGD, p::PArray{T})\n\nAccumulate the gradient ∇ℓ(λ,μ,q,η|X) in parallel for the phylogenetic profile matrix p.\n\n\n\n\n\n","category":"method"},{"location":"api/#Beluga.gradient-Union{Tuple{T}, Tuple{DLWGD{T,V} where V<:Union{NewickTree.TreeNode{Beluga.Branch{T}}, NewickTree.TreeNode{Beluga.Node{T}}},Array{Int64,1}}} where T<:Real","page":"API","title":"Beluga.gradient","text":"gradient(d::DLWGD, x::Vector)\n\nCompute the gradient of the log likelihood under the DLWGD model for a single count vector x, ∇ℓ(λ,μ,q,η|x).\n\nwarning: Warning\nCurrently the gradient seems to only work in NaN safe mode github issue\n\n\n\n\n\n","category":"method"},{"location":"api/#Beluga.init!-Tuple{RevJumpChain}","page":"API","title":"Beluga.init!","text":"init!(chain::RevJumpChain)\n\nInitialize the chain.\n\n\n\n\n\n","category":"method"},{"location":"api/#Beluga.posteriorE!-Tuple{Any}","page":"API","title":"Beluga.posteriorE!","text":"posteriorE!(chain)\n\nCompute E[Xi|Xparent=1,λ,μ] for the joint posterior; i.e. the expected number of lineages at node i under the linear birth-death process given that there was one lineage at the parent of i, for each sample from the posterior. This can give an idea of gene family expansion/contraction.\n\n\n\n\n\n","category":"method"},{"location":"api/#Beluga.posteriorΣ!-Tuple{Any}","page":"API","title":"Beluga.posteriorΣ!","text":"posteriorΣ!(chain)\n\nSample the covariance matrix of the bivariate process post hoc from the posterior under the Inverse Wishart prior. Based on Lartillot & Poujol 2010.\n\n\n\n\n\n","category":"method"},{"location":"api/#Beluga.pppvalues-Tuple{PostPredSim}","page":"API","title":"Beluga.pppvalues","text":"pppvalues(pps::PostPredSim)\n\nCompute posterior predictive p-values based on the posterior predictive distribution and the observed sumary statistics (see e.g. Gelman et al. 2013).\n\n\n\n\n\n","category":"method"},{"location":"api/#Beluga.removewgd!","page":"API","title":"Beluga.removewgd!","text":"removewgd!(d::DLWGD, n::ModelNode, reindex::Bool=true, set::Bool=true)\n\nRemove WGD/T node n from the DLWGD model. If reindex is true, the model nodes are reindexed to be consecutive. If set is true, the model internals (transition and extinction probabilities) are recomputed.\n\n\n\n\n\n","category":"function"},{"location":"api/#Beluga.removewgds!-Tuple{DLWGD}","page":"API","title":"Beluga.removewgds!","text":"removewgds(d::DLWGD)\n\nRemove all WGD nodes from the model.\n\n\n\n\n\n","category":"method"},{"location":"api/#Beluga.setrates!-Union{Tuple{T}, Tuple{DLWGD{T,V} where V<:Union{NewickTree.TreeNode{Beluga.Branch{T}}, NewickTree.TreeNode{Beluga.Node{T}}},Array{T,2}}} where T","page":"API","title":"Beluga.setrates!","text":"setrates!(model::DLWGD{T}, X::Matrix{T})\n\nSet duplication and loss rates for each non-wgd node|branch in the model. Rates should be provided as a 2 × n matrix, where the columns correspond to model node indices.\n\n\n\n\n\n","category":"method"},{"location":"api/#Distributions.logpdf!-Union{Tuple{T}, Tuple{Array{T,2},DLWGD{T,V} where V<:Union{NewickTree.TreeNode{Beluga.Branch{T}}, NewickTree.TreeNode{Beluga.Node{T}}},Array{Int64,1}}} where T<:Real","page":"API","title":"Distributions.logpdf!","text":"logpdf!(L::Matrix, d::DLWGD, x::Vector{Int64})\n\nCompute the log likelihood under the DLWGD model for a single count vector x ℓ(λ,μ,q,η|x) and update the dynamic programming matrix (L).\n\n\n\n\n\n","category":"method"},{"location":"api/#Distributions.logpdf!-Union{Tuple{T}, Tuple{Array{T,2},Union{NewickTree.TreeNode{Beluga.Branch{T}}, NewickTree.TreeNode{Beluga.Node{T}}},Array{Int64,1}}} where T<:Real","page":"API","title":"Distributions.logpdf!","text":"logpdf!(L::Matrix, n::ModelNode, x::Vector{Int64})\n\nCompute the log likelihood under the DLWGD model for a single count vector x ℓ(λ,μ,q,η|x) and update the dynamic programming matrix (L), only recomputing the matrix above node n.\n\n\n\n\n\n","category":"method"},{"location":"api/#Distributions.logpdf!-Union{Tuple{T}, Tuple{DLWGD,DistributedArrays.DArray{Profile{T},1,Array{Profile{T},1}}}} where T","page":"API","title":"Distributions.logpdf!","text":"logpdf!(d::DLWGD, p::PArray{T})\nlogpdf!(n::ModelNode, p::PArray{T})\n\nAccumulate the log-likelihood ℓ(λ,μ,q,η|X) in parallel for the phylogenetic profile matrix. If the first argument is a ModelNode, this will recompute the dynamic programming matrices starting from that node to save computation. Assumes (of course) that the phylogenetic profiles are iid from the same DLWGD model.\n\n\n\n\n\n","category":"method"},{"location":"api/#Distributions.logpdf-Tuple{DLWGD,Array{Int64,1}}","page":"API","title":"Distributions.logpdf","text":"logpdf(d::DLWGD, x::Vector{Int64})\n\nCompute the log likelihood under the DLWGD model for a single count vector x ℓ(λ,μ,q,η|x).\n\n\n\n\n\n","category":"method"},{"location":"api/#Beluga.AMMProposals","page":"API","title":"Beluga.AMMProposals","text":"AMMProposals(d)\n\nAdaptive Mixture Metropolis (AMM) proposals, where d is the dimensionality of the rates vector (should be 2 × number of nodes in tree).\n\n\n\n\n\n","category":"type"},{"location":"api/#Beluga.ConstantDistribution","page":"API","title":"Beluga.ConstantDistribution","text":"ConstantDistribution(x)\n\nA 'constant' distribution (Dirac mass), sometimes useful.\n\n\n\n\n\n","category":"type"},{"location":"api/#Beluga.MWGProposals","page":"API","title":"Beluga.MWGProposals","text":"MWGProposals\n\nProposals for the Metropolis-within-Gibbs algorithm. The MWG algorithm iterates over each node in the tree, resulting in very good mixing and fast convergence in terms of number of iterations, but has quite a high computational cost per generation.\n\n\n\n\n\n","category":"type"},{"location":"api/#Beluga.UpperBoundedGeometric","page":"API","title":"Beluga.UpperBoundedGeometric","text":"UpperBoundedGeometric{T<:Real}\n\nAn upper bounded geometric distribution, basically a constructor for a DiscreteNonParametric distribution with the relevant probabilities.\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.rand-Tuple{DLWGD,Int64}","page":"API","title":"Base.rand","text":"rand(d::DLWGD, N::Int64 [; condition::Vector{Vector{Symbol}}])\n\nSimulate N random phylogenetic profiles under the DLWGD model, subject to the constraint that there is at least one gene in each clade specified in the condition array. (by default conditioning is on non-extinction).\n\nExamples:\n\n```julia-repl julia> # include completely extinct families julia> rand(d, N, condition=[])\n\njulia> # condition on at least one lineage in both clades stemming from the root julia> rand(d, N, condition=Beluga.rootclades(d))\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.rand-Tuple{DLWGD}","page":"API","title":"Base.rand","text":"rand(d::DLWGD)\n\nSimulate a random phylogenetic profile from the DLWGD model.\n\n\n\n\n\n","category":"method"},{"location":"api/#Beluga.set!-Tuple{DLWGD}","page":"API","title":"Beluga.set!","text":"set!(d::DLWGD)\n\nCompute all model internals in postorder.\n\n\n\n\n\n","category":"method"},{"location":"rjmcmc/#WGD-inference-using-reversible-jump-MCMC-and-gene-count-data-1","page":"WGD inference using reversible-jump MCMC and gene count data","title":"WGD inference using reversible-jump MCMC and gene count data","text":"","category":"section"},{"location":"rjmcmc/#","page":"WGD inference using reversible-jump MCMC and gene count data","title":"WGD inference using reversible-jump MCMC and gene count data","text":"Load Beluga and required packages:","category":"page"},{"location":"rjmcmc/#","page":"WGD inference using reversible-jump MCMC and gene count data","title":"WGD inference using reversible-jump MCMC and gene count data","text":"using Beluga, CSV, Distributions","category":"page"},{"location":"rjmcmc/#","page":"WGD inference using reversible-jump MCMC and gene count data","title":"WGD inference using reversible-jump MCMC and gene count data","text":"Or, if you are running a julia session with multiple processes (when you started julia with -p option, or manually added workers using addprocs, see julia docs), run:","category":"page"},{"location":"rjmcmc/#","page":"WGD inference using reversible-jump MCMC and gene count data","title":"WGD inference using reversible-jump MCMC and gene count data","text":"using CSV, Distributions\n@everywhere using Beluga  # if julia is running in a parallel environment","category":"page"},{"location":"rjmcmc/#","page":"WGD inference using reversible-jump MCMC and gene count data","title":"WGD inference using reversible-jump MCMC and gene count data","text":"Then get some data (for instance from the example directory of the git repo)","category":"page"},{"location":"rjmcmc/#","page":"WGD inference using reversible-jump MCMC and gene count data","title":"WGD inference using reversible-jump MCMC and gene count data","text":"nw = readline(joinpath(@__DIR__, \"../../example/9dicots/9dicots.nw\"))\ndf = CSV.read(joinpath(@__DIR__, \"../../example/9dicots/9dicots-f01-25.csv\"))\nmodel, data = DLWGD(nw, df, 1.0, 1.2, 0.9)","category":"page"},{"location":"rjmcmc/#","page":"WGD inference using reversible-jump MCMC and gene count data","title":"WGD inference using reversible-jump MCMC and gene count data","text":"model now refers to the duplication-loss and WGD model (with no WGDs for now), data refers to the phylogenetic profile matrix. The model was initialized with all duplication and loss rates set to 1 and 1.2 respectively. You can check this easily:","category":"page"},{"location":"rjmcmc/#","page":"WGD inference using reversible-jump MCMC and gene count data","title":"WGD inference using reversible-jump MCMC and gene count data","text":"getrates(model)","category":"page"},{"location":"rjmcmc/#","page":"WGD inference using reversible-jump MCMC and gene count data","title":"WGD inference using reversible-jump MCMC and gene count data","text":"or to get the full parameter vector:","category":"page"},{"location":"rjmcmc/#","page":"WGD inference using reversible-jump MCMC and gene count data","title":"WGD inference using reversible-jump MCMC and gene count data","text":"asvector(model)","category":"page"},{"location":"rjmcmc/#","page":"WGD inference using reversible-jump MCMC and gene count data","title":"WGD inference using reversible-jump MCMC and gene count data","text":"Now you can easily compute log-likelihoods (and gradients thereof)","category":"page"},{"location":"rjmcmc/#","page":"WGD inference using reversible-jump MCMC and gene count data","title":"WGD inference using reversible-jump MCMC and gene count data","text":"logpdf!(model, data)","category":"page"},{"location":"rjmcmc/#","page":"WGD inference using reversible-jump MCMC and gene count data","title":"WGD inference using reversible-jump MCMC and gene count data","text":"so we can do likelihood-based inference (either maximum-likelihood or Bayesian). For the kind of problems tackled here, the only viable option however is Bayesian inference.","category":"page"},{"location":"rjmcmc/#","page":"WGD inference using reversible-jump MCMC and gene count data","title":"WGD inference using reversible-jump MCMC and gene count data","text":"We proceed by specifying the hierarchical prior on the gene family evolutionary process. There is no DSL available (à la Turing.jl, Mamba.jl, Soss.jl or Stan) but we use a fairly flexible prior struct. Here is an exaple for the (recommended) bivariate independent rates (IR) prior:","category":"page"},{"location":"rjmcmc/#","page":"WGD inference using reversible-jump MCMC and gene count data","title":"WGD inference using reversible-jump MCMC and gene count data","text":"prior = IRRevJumpPrior(\n    Ψ=[1 0. ; 0. 1],\n    X₀=MvNormal([0., 0.], [1 0. ; 0. 1]),\n    πK=DiscreteUniform(0,20),\n    πq=Beta(1,1),\n    πη=Beta(3,1),\n    Tl=treelength(model))","category":"page"},{"location":"rjmcmc/#","page":"WGD inference using reversible-jump MCMC and gene count data","title":"WGD inference using reversible-jump MCMC and gene count data","text":"Ψ is the prior covariance matrix for the Inverse-Wishart distribution. X₀ is the multivariate Normal prior on the mean duplication and loss rates. πK is the prior on the number of WGDs (i.e. the model indicator). πq is the Beta prior on the retention rates (iid). πη is the hyperprior on the parameter of the geometric distribution on the number of ancestral lineages at the root. Tl is the tree length (and is used for the prior on the WGD ages).","category":"page"},{"location":"rjmcmc/#","page":"WGD inference using reversible-jump MCMC and gene count data","title":"WGD inference using reversible-jump MCMC and gene count data","text":"To sample across model-space (i.e. where we infer the number and locations of WGDs), we need the reversible jump algorithm. There are several reversible-jump kernels implemented. The simplest is the aptly named SimpleKernel, which introduces new WGDs with a random retention rate drawn from a Beta distribution.","category":"page"},{"location":"rjmcmc/#","page":"WGD inference using reversible-jump MCMC and gene count data","title":"WGD inference using reversible-jump MCMC and gene count data","text":"kernel = SimpleKernel(qkernel=Beta(1,3))","category":"page"},{"location":"rjmcmc/#","page":"WGD inference using reversible-jump MCMC and gene count data","title":"WGD inference using reversible-jump MCMC and gene count data","text":"We can then construct a chain","category":"page"},{"location":"rjmcmc/#","page":"WGD inference using reversible-jump MCMC and gene count data","title":"WGD inference using reversible-jump MCMC and gene count data","text":"chain = RevJumpChain(data=data, model=model, prior=prior, kernel=kernel)\ninit!(chain)","category":"page"},{"location":"rjmcmc/#","page":"WGD inference using reversible-jump MCMC and gene count data","title":"WGD inference using reversible-jump MCMC and gene count data","text":"and sample from it:","category":"page"},{"location":"rjmcmc/#","page":"WGD inference using reversible-jump MCMC and gene count data","title":"WGD inference using reversible-jump MCMC and gene count data","text":"rjmcmc!(chain, 1000, show=50)","category":"page"},{"location":"rjmcmc/#","page":"WGD inference using reversible-jump MCMC and gene count data","title":"WGD inference using reversible-jump MCMC and gene count data","text":"This will log a part of the trace to stdout every show iterations, so that we're able to monitor a bit whether everything looks sensible. Of course in reality you would sample way longer than n=1000 iterations, but since this page has to be generated in decent time using a single CPU I'll keep it to 1000 here.","category":"page"},{"location":"rjmcmc/#","page":"WGD inference using reversible-jump MCMC and gene count data","title":"WGD inference using reversible-jump MCMC and gene count data","text":"Now the computer has done Bayesian inference, and we have to do our part. We can analyze the trace (in chain.trace), write it to a file, compute statistics, etc. Here are some trace plots:","category":"page"},{"location":"rjmcmc/#","page":"WGD inference using reversible-jump MCMC and gene count data","title":"WGD inference using reversible-jump MCMC and gene count data","text":"using Plots, DataFrames, LaTeXStrings\nburnin=100\np1 = plot(chain.trace[burnin:end,:λ1], label=L\"\\lambda_1\")\nplot!(chain.trace[burnin:end,:μ1], label=L\"\\mu_1\")\np2 = plot(chain.trace[burnin:end,:λ8], label=L\"\\lambda_8\")\nplot!(chain.trace[burnin:end,:μ8], label=L\"\\mu_8\")\np3 = plot(chain.trace[!,:k], label=L\"k\")\np4 = plot(chain.trace[!,:η1], label=L\"\\eta\")\nplot(p1,p2,p3,p4, grid=false, layout=(2,2))","category":"page"},{"location":"rjmcmc/#","page":"WGD inference using reversible-jump MCMC and gene count data","title":"WGD inference using reversible-jump MCMC and gene count data","text":"Clearly, we should sample way longer to get decent estimtes for the duplication rates (λ), loss rates (μ) and number of WGDs (k). Note how η is quite well-sampled already.","category":"page"},{"location":"rjmcmc/#","page":"WGD inference using reversible-jump MCMC and gene count data","title":"WGD inference using reversible-jump MCMC and gene count data","text":"We can also check the effective sample size (ESS) of the model indicator variable, for that we will use the method of Heck et al. (2019) implemented in the module DiscreteMarkovFit.jl:","category":"page"},{"location":"rjmcmc/#","page":"WGD inference using reversible-jump MCMC and gene count data","title":"WGD inference using reversible-jump MCMC and gene count data","text":"using DiscreteMarkovFit","category":"page"},{"location":"rjmcmc/#","page":"WGD inference using reversible-jump MCMC and gene count data","title":"WGD inference using reversible-jump MCMC and gene count data","text":"We'll discard a burnin of 100 iterations","category":"page"},{"location":"rjmcmc/#","page":"WGD inference using reversible-jump MCMC and gene count data","title":"WGD inference using reversible-jump MCMC and gene count data","text":"d = ObservedBirthDeathChain(Array(chain.trace[100:end,:k]))\nout = DiscreteMarkovFit.sample(d, 10000);\nnothing #hide","category":"page"},{"location":"rjmcmc/#","page":"WGD inference using reversible-jump MCMC and gene count data","title":"WGD inference using reversible-jump MCMC and gene count data","text":"This shows the effective sample size for the number of WGDs and the associated posterior probabilities. The maximum a posteriori (MAP) number of WGDs here is 3. When doing a serious analysis, one should aim for higher ESS values of course.","category":"page"},{"location":"rjmcmc/#","page":"WGD inference using reversible-jump MCMC and gene count data","title":"WGD inference using reversible-jump MCMC and gene count data","text":"We can also compute Bayes factors to get an idea of the number of WGDs for each branch in the species tree.","category":"page"},{"location":"rjmcmc/#","page":"WGD inference using reversible-jump MCMC and gene count data","title":"WGD inference using reversible-jump MCMC and gene count data","text":"bfs = bayesfactors(chain, burnin=100);\nnothing #hide","category":"page"},{"location":"rjmcmc/#","page":"WGD inference using reversible-jump MCMC and gene count data","title":"WGD inference using reversible-jump MCMC and gene count data","text":"This suggests strong support for WGD in quinoa (cqu) and poplar (ptr), which we now have very strong sigatures of ancestral WGDs in their genomes.  Note that we already detect these WGDs using a mere 25 gene families as data!","category":"page"},{"location":"rjmcmc/#","page":"WGD inference using reversible-jump MCMC and gene count data","title":"WGD inference using reversible-jump MCMC and gene count data","text":"A plot of the posterior probabilities for the number of WGDs on each branch is a nice way to summarize the rjMCMC output:","category":"page"},{"location":"rjmcmc/#","page":"WGD inference using reversible-jump MCMC and gene count data","title":"WGD inference using reversible-jump MCMC and gene count data","text":"plots = [bar(g[!,:k], g[!,:p1], color=:white,\n            title=join(string.(g[1,:clade]), \", \"))\n            for g in groupby(bfs, :branch)]\nxlabel!.(plots[end-3:end], L\"k\")\nylabel!.(plots[1:4:end], L\"P(k|X)\")\nplot(plots..., grid=false, legend=false,\n    ylim=(0,1), xlim=(-0.5,3.5),\n    yticks=[0, 0.5, 1], xticks=0:3,\n    title_loc=:left, titlefont=8)","category":"page"},{"location":"rjmcmc/#","page":"WGD inference using reversible-jump MCMC and gene count data","title":"WGD inference using reversible-jump MCMC and gene count data","text":"","category":"page"},{"location":"rjmcmc/#","page":"WGD inference using reversible-jump MCMC and gene count data","title":"WGD inference using reversible-jump MCMC and gene count data","text":"This page was generated using Literate.jl.","category":"page"},{"location":"prior/#Sample-from-the-prior-using-rjMCMC-1","page":"Sample from the prior using rjMCMC","title":"Sample from the prior using rjMCMC","text":"","category":"section"},{"location":"prior/#","page":"Sample from the prior using rjMCMC","title":"Sample from the prior using rjMCMC","text":"Running an MCMC algorithm without data should result in a sample from the prior. This is commonly used in complicated Bayesian inference settings such as those arising in phylogenetics to verify correct implemetation of an MCMC algorithm. Of course, this cannot idicate probems in the likelihood implementation! (which can also be quite complicated in phylogenetic applications, at least in my humble opinion).","category":"page"},{"location":"prior/#","page":"Sample from the prior using rjMCMC","title":"Sample from the prior using rjMCMC","text":"using Distributions, Beluga, Plots, StatsPlots, LaTeXStrings, Random\nRandom.seed!(190894)","category":"page"},{"location":"prior/#","page":"Sample from the prior using rjMCMC","title":"Sample from the prior using rjMCMC","text":"Obtain the species tree","category":"page"},{"location":"prior/#","page":"Sample from the prior using rjMCMC","title":"Sample from the prior using rjMCMC","text":"nw = readline(joinpath(@__DIR__, \"../../example/9dicots/9dicots.nw\"))\nd, p = DLWGD(nw, 1., 1., 0.9)","category":"page"},{"location":"prior/#","page":"Sample from the prior using rjMCMC","title":"Sample from the prior using rjMCMC","text":"Calling DLWGD without a data frame with gene counts will result in a 'mock' phylogenetic profile for which the likelihood defaults to 1 (or log-likelihood to 0).","category":"page"},{"location":"prior/#","page":"Sample from the prior using rjMCMC","title":"Sample from the prior using rjMCMC","text":"logpdf!(d, p)","category":"page"},{"location":"prior/#","page":"Sample from the prior using rjMCMC","title":"Sample from the prior using rjMCMC","text":"The prior is specified here","category":"page"},{"location":"prior/#","page":"Sample from the prior using rjMCMC","title":"Sample from the prior using rjMCMC","text":"prior = IRRevJumpPrior(\n    Ψ=[1 0.0 ; 0.0 1],\n    X₀=MvNormal(log.([3,3]), [0.2 0.; 0. 0.2]),\n    πK=DiscreteUniform(0, 10),\n    πq=Beta(1,3),\n    πη=Beta(3,1),\n    Tl=treelength(d))","category":"page"},{"location":"prior/#","page":"Sample from the prior using rjMCMC","title":"Sample from the prior using rjMCMC","text":"Ψ is the prior covariance matrix for the Inverse-Wishart distribution. X₀ is the multivariate Normal prior on the mean duplication and loss rates. πK is the prior on the number of WGDs (i.e. the model indicator). πq is the Beta prior on the retention rates (iid). πη is the hyperprior on the parameter of the geometric distribution on the number of ancestral lineages at the root. Tl is the tree length (and is used for the prior on the WGD ages).","category":"page"},{"location":"prior/#","page":"Sample from the prior using rjMCMC","title":"Sample from the prior using rjMCMC","text":"We have to set the rjMCMC kernel,","category":"page"},{"location":"prior/#","page":"Sample from the prior using rjMCMC","title":"Sample from the prior using rjMCMC","text":"kernel = SimpleKernel(qkernel=Beta(1,3))","category":"page"},{"location":"prior/#","page":"Sample from the prior using rjMCMC","title":"Sample from the prior using rjMCMC","text":"construct the chain","category":"page"},{"location":"prior/#","page":"Sample from the prior using rjMCMC","title":"Sample from the prior using rjMCMC","text":"chain = RevJumpChain(data=p, model=d, prior=prior, kernel=kernel)\ninit!(chain)","category":"page"},{"location":"prior/#","page":"Sample from the prior using rjMCMC","title":"Sample from the prior using rjMCMC","text":"and sample","category":"page"},{"location":"prior/#","page":"Sample from the prior using rjMCMC","title":"Sample from the prior using rjMCMC","text":"@time rjmcmc!(chain, 5000, trace=5, show=1000)","category":"page"},{"location":"prior/#","page":"Sample from the prior using rjMCMC","title":"Sample from the prior using rjMCMC","text":"Now plot some stuff","category":"page"},{"location":"prior/#","page":"Sample from the prior using rjMCMC","title":"Sample from the prior using rjMCMC","text":"p1 = bar(Beluga.freqmap(chain.trace[!,:k]), color=:white, title=L\"k\")\nplot!(p1, prior.πK, color=:black, marker=nothing)\np2 = stephist(log.(chain.trace[!,:λ1]), fill=true, color=:black, alpha=0.2, normalize=true)\nplot!(p2, Normal(log(3),√0.2), color=:black, linewidth=2, title=L\"\\lambda\")\nstephist!(log.(chain.trace[!,:λ9]), fill=true, color=:firebrick, alpha=0.2, normalize=true)\np3 = stephist(log.(chain.trace[!,:μ1]), fill=true, color=:black, alpha=0.2, normalize=true)\nplot!(p3, Normal(log(3),√0.2), color=:black, linewidth=2, title=L\"\\mu\")\nstephist!(log.(chain.trace[!,:μ4]), fill=true, color=:firebrick, alpha=0.2, normalize=true)\np4 = stephist(chain.trace[!,:η1], color=:black, fill=true, alpha=0.2, normalize=true)\nplot!(prior.πη, linewidth=2, color=:black, title=L\"\\eta\")\nplot(p1, p2, p3, p4, layout=(2,2), legend=false, grid=false, title_loc=:left)","category":"page"},{"location":"prior/#","page":"Sample from the prior using rjMCMC","title":"Sample from the prior using rjMCMC","text":"Note that the prior for duplication and loss rates can have very heavy tails under the molecular clock priors (see the distributions in red as examples).","category":"page"},{"location":"prior/#","page":"Sample from the prior using rjMCMC","title":"Sample from the prior using rjMCMC","text":"","category":"page"},{"location":"prior/#","page":"Sample from the prior using rjMCMC","title":"Sample from the prior using rjMCMC","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#Beluga.jl-1","page":"Introduction","title":"Beluga.jl","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Beluga is a julia library for the statistical analysis of gene family evolution using phylogenetic birth-death processes. It's somewhat related to Whale.jl as it implements models of duplication loss and whole-genome duplication, but employs gene count data instead of gene trees. The library implements the MCMC sampler of Zwaenepoel & Van de Peer (2019) as well as the reversible-jump MCMC sampler of Zwaenepoel & Van de Peer (2020, in preparation).","category":"page"},{"location":"#Data-preparation-1","page":"Introduction","title":"Data preparation","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"To perform analyses with Beluga, you will need  ","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"A species tree with branch lengths (preferbly an ultrametric time tree)\nA phylogenetic profile matrix. If you have a bunch of protein fasta files for a set of species of interest, this can be easily obtained using e.g. OrthoFinder.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"note: Note\nIf you only need the phylogenetic profile matrix from OrthoFinder, be sure to use the -og flag to stop the OrthoFinder pipeline after orthogroup inference. The phylogenetic profile matrix can be found in the Orthogroups.GeneCount.tsv file.","category":"page"},{"location":"mle/#Maximum-likelihood-estimation-for-the-DLWGD-model-using-Beluga.jl-1","page":"Maximum likelihood estimation for the DLWGD model using Beluga.jl","title":"Maximum likelihood estimation for the DLWGD model using Beluga.jl","text":"","category":"section"},{"location":"mle/#","page":"Maximum likelihood estimation for the DLWGD model using Beluga.jl","title":"Maximum likelihood estimation for the DLWGD model using Beluga.jl","text":"We'll need the folowing packages loaded:","category":"page"},{"location":"mle/#","page":"Maximum likelihood estimation for the DLWGD model using Beluga.jl","title":"Maximum likelihood estimation for the DLWGD model using Beluga.jl","text":"using Beluga, CSV, DataFrames, Optim","category":"page"},{"location":"mle/#","page":"Maximum likelihood estimation for the DLWGD model using Beluga.jl","title":"Maximum likelihood estimation for the DLWGD model using Beluga.jl","text":"First let's get a random data set","category":"page"},{"location":"mle/#","page":"Maximum likelihood estimation for the DLWGD model using Beluga.jl","title":"Maximum likelihood estimation for the DLWGD model using Beluga.jl","text":"nw = \"(D:0.1803,(C:0.1206,(B:0.0706,A:0.0706):0.0499):0.0597);\"\nm, _ = DLWGD(nw, 1.0, 1.5, 0.8)\ndf = rand(m, 1000, condition=Beluga.rootclades(m))\nfirst(df, 5)","category":"page"},{"location":"mle/#","page":"Maximum likelihood estimation for the DLWGD model using Beluga.jl","title":"Maximum likelihood estimation for the DLWGD model using Beluga.jl","text":"This illustrates how to simulate data from a DLWGD model instance. We created a DLWGD model for the species tree in the Newick string nw with constant rates of duplication (1.0) and loss (1.5) across the tree and a geometric prior distribution on the number of lineages at the root with mean 1.25 (η = 0.8). We then simulated 1000 gene family profiles subject to the condition that there is at least one gene observed at the leaves in each clade stemming from the root.","category":"page"},{"location":"mle/#","page":"Maximum likelihood estimation for the DLWGD model using Beluga.jl","title":"Maximum likelihood estimation for the DLWGD model using Beluga.jl","text":"No we set up some stuff to do maximum likelihood estimation for the constant rates model. But first we'll have to get the proper data structure for the profiles","category":"page"},{"location":"mle/#","page":"Maximum likelihood estimation for the DLWGD model using Beluga.jl","title":"Maximum likelihood estimation for the DLWGD model using Beluga.jl","text":"model, data = DLWGD(nw, df)","category":"page"},{"location":"mle/#","page":"Maximum likelihood estimation for the DLWGD model using Beluga.jl","title":"Maximum likelihood estimation for the DLWGD model using Beluga.jl","text":"Note that we already got a model object above, however some internals of the model are dependent on the data to which it will be applied (due to the algorithm of Csuros & Miklos).","category":"page"},{"location":"mle/#","page":"Maximum likelihood estimation for the DLWGD model using Beluga.jl","title":"Maximum likelihood estimation for the DLWGD model using Beluga.jl","text":"Now for some functions needed for the ML estimation","category":"page"},{"location":"mle/#","page":"Maximum likelihood estimation for the DLWGD model using Beluga.jl","title":"Maximum likelihood estimation for the DLWGD model using Beluga.jl","text":"n = Beluga.ne(model) + 1  # number of nodes = number of edges + 1\nfullvec(θ, η=0.8, n=n) = [repeat([exp(θ[1])], n); repeat([exp(θ[2])], n) ; η]\nf(θ) = -logpdf!(model(fullvec(θ)), data)\ng!(G, θ) = G .= -1 .* Beluga.gradient_cr(model(fullvec(θ)), data)","category":"page"},{"location":"mle/#","page":"Maximum likelihood estimation for the DLWGD model using Beluga.jl","title":"Maximum likelihood estimation for the DLWGD model using Beluga.jl","text":"The default DLWGD model is parameterized with a rate for each node in the tree, and a DLWGD model with n nodes and k WGDs can be constructed based on a given DLWGD model instance and a vector looking like [[λ1 … λn] ; [μ1 … μn] ; [q1 … qk] ; η]. To be clear, consider the following example code","category":"page"},{"location":"mle/#","page":"Maximum likelihood estimation for the DLWGD model using Beluga.jl","title":"Maximum likelihood estimation for the DLWGD model using Beluga.jl","text":"@show v = asvector(model)\nnewmodel = model(rand(length(v)))\n@show asvector(newmodel)","category":"page"},{"location":"mle/#","page":"Maximum likelihood estimation for the DLWGD model using Beluga.jl","title":"Maximum likelihood estimation for the DLWGD model using Beluga.jl","text":"In the constant rates model, we assume all duplication rates and all loss rates are identical across the tree respectively. The fullvec(θ) function defined above will construct a full model vector, from which we can construct a DLWGD instance, from the simpler vector θ = [log(λ), log(μ)] that defines the constant rates model.","category":"page"},{"location":"mle/#","page":"Maximum likelihood estimation for the DLWGD model using Beluga.jl","title":"Maximum likelihood estimation for the DLWGD model using Beluga.jl","text":"Now for optimization. Let's try two optimization algorithms, one only using the likelihood (using the Nelder-Mead downhill simplex algorithm), and another using gradient information (using the LBFGS algorithm)","category":"page"},{"location":"mle/#","page":"Maximum likelihood estimation for the DLWGD model using Beluga.jl","title":"Maximum likelihood estimation for the DLWGD model using Beluga.jl","text":"Using Nelder-Mead","category":"page"},{"location":"mle/#","page":"Maximum likelihood estimation for the DLWGD model using Beluga.jl","title":"Maximum likelihood estimation for the DLWGD model using Beluga.jl","text":"init = randn(2)\nresults = optimize(f, init)\n@show exp.(results.minimizer)","category":"page"},{"location":"mle/#","page":"Maximum likelihood estimation for the DLWGD model using Beluga.jl","title":"Maximum likelihood estimation for the DLWGD model using Beluga.jl","text":"Using LBFGS (requires gradients!)","category":"page"},{"location":"mle/#","page":"Maximum likelihood estimation for the DLWGD model using Beluga.jl","title":"Maximum likelihood estimation for the DLWGD model using Beluga.jl","text":"init = randn(2)\nresults = optimize(f, g!, init)\n@show exp.(results.minimizer)","category":"page"},{"location":"mle/#","page":"Maximum likelihood estimation for the DLWGD model using Beluga.jl","title":"Maximum likelihood estimation for the DLWGD model using Beluga.jl","text":"warning: Warning\nCurrently the gradient seems to only work in NaN safe mode. In order to enable NaN safe mode, you should change a line in the ForwardDiff source code. On Linux, and assuming you use julia v1.3, the following should work for most people:rm -r ~/.julia/compiled/v1.3/ForwardDiff\nsed -i 's/NANSAFE_MODE_ENABLED = false/NANSAFE_MODE_ENABLED = true/g' \\\n~/.julia/packages/ForwardDiff/*/src/prelude.jl","category":"page"},{"location":"mle/#","page":"Maximum likelihood estimation for the DLWGD model using Beluga.jl","title":"Maximum likelihood estimation for the DLWGD model using Beluga.jl","text":"","category":"page"},{"location":"mle/#","page":"Maximum likelihood estimation for the DLWGD model using Beluga.jl","title":"Maximum likelihood estimation for the DLWGD model using Beluga.jl","text":"This page was generated using Literate.jl.","category":"page"}]
}
